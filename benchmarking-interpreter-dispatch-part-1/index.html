<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
<title>Benchmarking interpreter dispatch: part 1 (WIP) | Bitsdraumar</title>



<meta property="og:title" content="Benchmarking interpreter dispatch: part 1 (WIP)">




<meta property="og:locale" content="en-US">




<link rel="canonical" href="https://www.bitsdraumar.is/benchmarking-interpreter-dispatch-part-1/">
<meta property="og:url" content="https://www.bitsdraumar.is/benchmarking-interpreter-dispatch-part-1/">



<meta property="og:site_name" content="Bitsdraumar" />





  <meta property="og:type" content="article" />
  <meta property="article:published_time" content="2024-01-11T11:11:00+00:00">







  <meta name="twitter:card" content="summary">



  <meta property="twitter:title" content="Benchmarking interpreter dispatch: part 1 (WIP)">








<script type="application/ld+json">
{
  "author": {
    "@type":"Person",
	  "name":"",
  },
  "description": "",
  "url": "https://www.bitsdraumar.is/benchmarking-interpreter-dispatch-part-1/",
  "@context":"https://schema.org",
  "@type": "BlogPosting",
  "headline": "Benchmarking interpreter dispatch: part 1 (WIP)"
  
    
    
      "datePublished":"2024-01-11T11:11:00+00:00",
    
    "mainEntityOfPage":{
      "@type":"WebPage",
      "@id":"https://www.bitsdraumar.is/benchmarking-interpreter-dispatch-part-1/"
    },
  
}
</script>

  <link rel="stylesheet" href="https://www.bitsdraumar.is/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">
  <link href="https://fonts.cdnfonts.com/css/norse" rel="stylesheet">
                

  <link rel="icon" type="image/png" sizes="32x32" href="https://www.bitsdraumar.is/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://www.bitsdraumar.is/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://www.bitsdraumar.is/assets/apple-touch-icon.png">

  
    <link type="application/atom+xml" rel="alternate" href="https://www.bitsdraumar.is/rss.xml" title="Bitsdraumar" />
  

  

  
  
</head>

<body>
  
  <nav class="nav">
    <div class="nav-container">
      <a href="https://www.bitsdraumar.is">
        <h2 class="nav-title">Bitsdraumar</h2>
      </a>
      <ul>
        
          <li><a href="https://www.bitsdraumar.is">Posts</a></li>
          <li><a href="https://www.bitsdraumar.is/tags">Tags</a></li>
          <li><a href="https://www.bitsdraumar.is/about">About & Projects</a></li>
        
      </ul>
    </div>
  </nav>
  

  <main>
    
  <div class="post">
  	<div class="post-info">
  		
  		<span>on&nbsp;</span><time datetime="2024-01-11T11:11:00+00:00">January 11, 2024</time>
  	</div>
  	<h1 class="post-title">Benchmarking interpreter dispatch: part 1 (WIP)</h1>
  	<div class="post-line"></div>
  	<p>In this series we will be analyzing and evaluating various interpreter dispatch techniques and their performance characteristics.</p>
<span id="continue-reading"></span>
<p>Most dynamic programming languages handle execution via an interpreter core.
In many cases this is implemented via a simple while-switch loop where dispatch is done
on an instruction opcode, as evidenced here in <a href="https://github.com/lua/lua/blob/v5.4.0/lvm.c#L1158">Lua</a> (though as you can see, there's an optional indirect dispatch variant, as is the case in many other similar scripting languages).</p>
<p>In this post we'll explore the most popular alternative to this switch dispatch - the indirect threaded, jump table dispatch.
More specifically, the performance differences.<br />
Newer processor architectures have significantly improved branch predictors, so it may be interesting to see
If the gap has been narrowed over the years.</p>
<p>In indirect dispatch, instead a loop and a switch, we just have labels for each of the instruction opcodes (types) and an array containing the adresses of those labels.
So the way we jump to those labels is by indexing the array with the instruction opcode. Pretty nifty, right?</p>
<p>There are alternative approaches that, instead of bytecode, interpret AST nodes or even the source code line-by-line.
They won't be covered as they are not quite as efficient.</p>
<p>The next section will contain a short explanation of the techniques, so if you're familiar with them
or maybe you just want to see the numbers, feel free to skip it!</p>
<h1 id="dispatch-techniques">Dispatch techniques</h1>
<h2 id="switch-based-dispatch">Switch-based dispatch</h2>
<p>This dispatch is very simple. The while loop loops endlessly, fetching the next instruction and dispatching based on the instruction opcode.
As shown below:</p>
<pre data-lang="c" style="background-color:#2e3440;color:#d8dee9;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#81a1c1;">int </span><span style="color:#88c0d0;">swtch</span><span>(</span><span style="color:#81a1c1;">unsigned char* </span><span>ip) {
</span><span>    </span><span style="color:#81a1c1;">int</span><span> counter </span><span style="color:#81a1c1;">= </span><span style="color:#b48ead;">0</span><span style="color:#eceff4;">,</span><span> ret </span><span style="color:#81a1c1;">= </span><span style="color:#b48ead;">0</span><span style="color:#eceff4;">;
</span><span>
</span><span>    </span><span style="color:#81a1c1;">while</span><span>(</span><span style="color:#b48ead;">1</span><span>) {
</span><span>        </span><span style="color:#81a1c1;">switch</span><span>(</span><span style="color:#81a1c1;">*</span><span>ip</span><span style="color:#81a1c1;">++</span><span>) {
</span><span>            </span><span style="color:#81a1c1;">case </span><span style="color:#b48ead;">0</span><span style="color:#eceff4;">: </span><span style="color:#616e88;">// INC 1
</span><span>                ret</span><span style="color:#81a1c1;">++</span><span style="color:#eceff4;">;
</span><span>                </span><span style="color:#81a1c1;">break</span><span style="color:#eceff4;">;
</span><span>            </span><span style="color:#81a1c1;">case </span><span style="color:#b48ead;">1</span><span style="color:#eceff4;">: </span><span style="color:#616e88;">// DEC 1
</span><span>                ret</span><span style="color:#81a1c1;">--</span><span style="color:#eceff4;">;
</span><span>                </span><span style="color:#81a1c1;">break</span><span style="color:#eceff4;">;
</span><span>            </span><span style="color:#81a1c1;">case </span><span style="color:#b48ead;">2</span><span style="color:#eceff4;">: </span><span style="color:#616e88;">// INC 2
</span><span>                ret </span><span style="color:#81a1c1;">+= </span><span style="color:#b48ead;">2</span><span style="color:#eceff4;">;
</span><span>                </span><span style="color:#81a1c1;">break</span><span style="color:#eceff4;">;
</span><span>            </span><span style="color:#81a1c1;">case </span><span style="color:#b48ead;">3</span><span style="color:#eceff4;">: </span><span style="color:#616e88;">// LOOP
</span><span>                </span><span style="color:#81a1c1;">if</span><span>(counter</span><span style="color:#81a1c1;">++ &lt; </span><span style="color:#b48ead;">100000</span><span>)
</span><span>                    ip</span><span style="color:#81a1c1;">--</span><span style="color:#eceff4;">;
</span><span>                </span><span style="color:#81a1c1;">break</span><span style="color:#eceff4;">;
</span><span>            </span><span style="color:#81a1c1;">case </span><span style="color:#b48ead;">4</span><span style="color:#eceff4;">: </span><span style="color:#616e88;">// RET
</span><span>                </span><span style="color:#81a1c1;">return</span><span> ret</span><span style="color:#eceff4;">;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<h2 id="indirect-threading">Indirect threading</h2>
<p>This technique involves using GCC's computed goto extension, where we can <code>goto</code> to a dynamically computed/chosen label.</p>
<p>It's structured as a static jump table that contains addresses to labels for all of the instruction handling branches, each instruction handler is simply a label followed by the code that executes the actual instruction.</p>
<p>There is no outer loop here, each instruction handler takes care of the dispatch by fetching the next instruction, indexing the jump table by the opcode value and jumping to that label.<br />
And thus the dispatch code is replicated in each branch instead of being centralised as seen in the switch version, which may seem wasteful, but the the cycle savings are worth it.</p>
<p>It sounds more complicated that it is, the simple example below should clear things right up.</p>
<pre data-lang="c" style="background-color:#2e3440;color:#d8dee9;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#81a1c1;">int </span><span style="color:#88c0d0;">indirect</span><span>(</span><span style="color:#81a1c1;">unsigned char* </span><span>ip) {
</span><span>    </span><span style="color:#81a1c1;">int</span><span> counter </span><span style="color:#81a1c1;">= </span><span style="color:#b48ead;">0</span><span style="color:#eceff4;">,</span><span> ret </span><span style="color:#81a1c1;">= </span><span style="color:#b48ead;">0</span><span style="color:#eceff4;">;
</span><span>
</span><span>    </span><span style="color:#81a1c1;">static void*</span><span> jump_table[] </span><span style="color:#81a1c1;">= </span><span>{
</span><span>        </span><span style="color:#81a1c1;">&amp;&amp;</span><span>add</span><span style="color:#eceff4;">,
</span><span>        </span><span style="color:#81a1c1;">&amp;&amp;</span><span>sub</span><span style="color:#eceff4;">,
</span><span>        </span><span style="color:#81a1c1;">&amp;&amp;</span><span>add2</span><span style="color:#eceff4;">,
</span><span>        </span><span style="color:#81a1c1;">&amp;&amp;</span><span>loop</span><span style="color:#eceff4;">,
</span><span>        </span><span style="color:#81a1c1;">&amp;&amp;</span><span>ret</span><span style="color:#eceff4;">,
</span><span>    }</span><span style="color:#eceff4;">;
</span><span>
</span><span>    </span><span style="color:#81a1c1;">goto *</span><span>jump_table[</span><span style="color:#81a1c1;">*</span><span>ip</span><span style="color:#81a1c1;">++</span><span>]</span><span style="color:#eceff4;">;
</span><span>
</span><span>    </span><span style="color:#5e81ac;">add</span><span style="color:#eceff4;">:
</span><span>        ret</span><span style="color:#81a1c1;">++</span><span style="color:#eceff4;">;
</span><span>        </span><span style="color:#81a1c1;">goto *</span><span>jump_table[</span><span style="color:#81a1c1;">*</span><span>ip</span><span style="color:#81a1c1;">++</span><span>]</span><span style="color:#eceff4;">;
</span><span>    </span><span style="color:#5e81ac;">sub</span><span style="color:#eceff4;">:
</span><span>        ret</span><span style="color:#81a1c1;">--</span><span style="color:#eceff4;">;
</span><span>        </span><span style="color:#81a1c1;">goto *</span><span>jump_table[</span><span style="color:#81a1c1;">*</span><span>ip</span><span style="color:#81a1c1;">++</span><span>]</span><span style="color:#eceff4;">;
</span><span>    </span><span style="color:#5e81ac;">add2</span><span style="color:#eceff4;">:
</span><span>        ret </span><span style="color:#81a1c1;">+= </span><span style="color:#b48ead;">2</span><span style="color:#eceff4;">;
</span><span>        </span><span style="color:#81a1c1;">goto *</span><span>jump_table[</span><span style="color:#81a1c1;">*</span><span>ip</span><span style="color:#81a1c1;">++</span><span>]</span><span style="color:#eceff4;">;
</span><span>    </span><span style="color:#5e81ac;">loop</span><span style="color:#eceff4;">:
</span><span>        </span><span style="color:#81a1c1;">if</span><span>(counter</span><span style="color:#81a1c1;">++ &lt; </span><span style="color:#b48ead;">100000</span><span>)
</span><span>            ip</span><span style="color:#81a1c1;">--</span><span style="color:#eceff4;">;
</span><span>        </span><span style="color:#81a1c1;">goto *</span><span>jump_table[</span><span style="color:#81a1c1;">*</span><span>ip</span><span style="color:#81a1c1;">++</span><span>]</span><span style="color:#eceff4;">;
</span><span>    </span><span style="color:#5e81ac;">ret</span><span style="color:#eceff4;">:
</span><span>        </span><span style="color:#81a1c1;">return</span><span> ret</span><span style="color:#eceff4;">;
</span><span>}
</span></code></pre>
<h1 id="benchmarking">Benchmarking</h1>
<p>So for the purposes of benchmarking, we'll write a simple VM.</p>
<p>It only contains the bare minimum, since we only need to benchmark the dispatch overhead itself.
There's a few extra instructions in there, otherwise gcc does some weird basic block generation that's not
really representative of a typical interpreter.</p>
<p>So, on to the code.</p>
<p>(TODO)</p>
<p>Switch</p>
<p>Indirect</p>
<h1 id="results">Results</h1>
<p>Graph</p>
<p>(TODO)</p>

  </div>

	

  <div class="pagination">
  	
		<a href="#" class="top">Top</a>
		
  </div>

  </main>

  
  <footer>

  </footer>
  
</body>
</html>
